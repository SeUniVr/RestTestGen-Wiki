{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"overviewSidebar":[{"type":"link","label":"RestTestGen","href":"/docs/rtg","docId":"rtg","unlisted":false},{"type":"link","label":"Automated API Testing","href":"/docs/automated-testing","docId":"automated-testing","unlisted":false}],"frameworkSidebar":[{"type":"link","label":"RTG Components","href":"/docs/rtg-framework/components/core-extensibile-description","docId":"rtg-framework/components/core-extensibile-description","unlisted":false},{"type":"category","label":"Components","items":[{"type":"link","label":"Operation Sorter","href":"/docs/rtg-framework/operation-sorter/","docId":"rtg-framework/operation-sorter/operation-sorter","unlisted":false},{"type":"link","label":"Parameters","href":"/docs/rtg-framework/datatype/parameters","docId":"rtg-framework/datatype/parameters","unlisted":false},{"type":"link","label":"Error Fuzzer","href":"/docs/rtg-framework/fuzzer/error-fuzzer","docId":"rtg-framework/fuzzer/error-fuzzer","unlisted":false},{"type":"link","label":"Parameter Value Provider","href":"/docs/rtg-framework/pvp/","docId":"rtg-framework/pvp/pvp","unlisted":false},{"type":"link","label":"Interaction Processor","href":"/docs/rtg-framework/interaction-processor/","docId":"rtg-framework/interaction-processor/interaction-processor","unlisted":false},{"type":"link","label":"Mutator","href":"/docs/rtg-framework/mutator/","docId":"rtg-framework/mutator/mutator","unlisted":false},{"type":"link","label":"Oracle","href":"/docs/rtg-framework/oracle/","docId":"rtg-framework/oracle/oracle","unlisted":false},{"type":"link","label":"Writer","href":"/docs/rtg-framework/writer/","docId":"rtg-framework/writer/writer","unlisted":false}],"collapsed":true,"collapsible":true,"href":"/docs/category/components"}],"strategiesSidebar":[{"type":"link","label":"Strategy","href":"/docs/rtg-tool/strategy/introduction","docId":"rtg-tool/strategy/introduction","unlisted":false},{"type":"link","label":"Nominal and Error Strategy","href":"/docs/rtg-tool/strategy/nominal-error-strategy","docId":"rtg-tool/strategy/nominal-error-strategy","unlisted":false},{"type":"link","label":"Mass Assignment Strategy","href":"/docs/rtg-tool/strategy/mass-assignment-strategy","docId":"rtg-tool/strategy/mass-assignment-strategy","unlisted":false},{"type":"link","label":"NLP Strategy","href":"/docs/rtg-tool/strategy/nlp-strategy","docId":"rtg-tool/strategy/nlp-strategy","unlisted":false}]},"docs":{"automated-testing":{"id":"automated-testing","title":"Automated API Testing","description":"Typically, an API (Application Programming Interface) is a set of rules and protocols that allow software to communicate with each other by exchanging data and information. API architecture, in general, is explained in terms of client and server: there is an application that sends a request (client) and an application that sends the response (server).","sidebar":"overviewSidebar"},"rtg":{"id":"rtg","title":"RestTestGen","description":"RestTestGen is a testing framework created to automatically generate test cases for the REST API. The assumption made a priori is that one cannot have direct access to the source code, but only to the OpenAPI specification, and that one can interact with the REST API directly via the HTTP protocol.","sidebar":"overviewSidebar"},"rtg-framework/components/core":{"id":"rtg-framework/components/core","title":"Core Components","description":"The tool provides researchers and practitioners with some “core components” that are presented in detail below."},"rtg-framework/components/core-extensibile-description":{"id":"rtg-framework/components/core-extensibile-description","title":"RTG Components","description":"The architecture of RTG can be seen in the figure. It provides developers and researchers with two types of components. it is possible to find core components that work out-of-the box, and extensible components that can be re-implemented to give developers, or those who need them, the possibility of creating totally customised strategies.","sidebar":"frameworkSidebar"},"rtg-framework/components/extensible":{"id":"rtg-framework/components/extensible","title":"Extensible Components","description":"These components are a set of abstract and concrete classes for which researchers or experts might want to provide a new implementation to realise their new testing algorithm."},"rtg-framework/datatype/operation":{"id":"rtg-framework/datatype/operation","title":"Operation","description":""},"rtg-framework/datatype/parameters":{"id":"rtg-framework/datatype/parameters","title":"Parameters","description":"The abstract class `Parameter` provides the representation of a parameter within the OpenAPI specification. Parameters are used in HTTP requests to pass data, e.g. in query parameters, header, body, ...","sidebar":"frameworkSidebar"},"rtg-framework/fuzzer/error-fuzzer":{"id":"rtg-framework/fuzzer/error-fuzzer","title":"Error Fuzzer","description":"This class generates mutant test sequences by applying changes to the parameters of API requests to test their robustness and error handling capability. The aim is to simulate erroneous inputs to test the API's error handling. Mutations are applied to request parameters to generate variants with missing values, wrong types or violated constraints. Finally, mutated sequences are executed and evaluated to test the behaviour of the API in abnormal scenarios.  The operation of the Fuzzer is explained below. First, a test sequence is passed in to be modified. Mutators are defined (e.g. `MissingrequiredParameterMutator`, `WrongTypeParameterMutator`, `ConstraintViolationParameterMutator`). After that, mutated sequences are generated and, for each interaction of the original sequence, n variants are created. An applicable mutator is randomly selected and this new interaction is created and executed by a `TestRunner`.  The report is also written using ReportWriter and RestAssuredWriter.","sidebar":"frameworkSidebar"},"rtg-framework/fuzzer/fuzzer":{"id":"rtg-framework/fuzzer/fuzzer","title":"Fuzzer","description":"A fuzzer is an automatic testing tool that injects random or mutated input into a system to detect errors, vulnerabilities or unexpected behaviour."},"rtg-framework/fuzzer/mass-assignment-fuzzer":{"id":"rtg-framework/fuzzer/mass-assignment-fuzzer","title":"Mass Assignment Fuzzer","description":"This fuzzer deals with generating sequences to check the vulnerability of mass assignments.  This class accepts an object of type CrudGroup that contains a set of CRUD operations on an object. These operations are divided into distinct sets. The “producer”, “consumer” and “read-only” parameters are identified (i.e. they are returned by read operations but are never modified). After that, test sequences are generated to inject the parameters into CRUD operations. These sequences test how a REST API handles mass assignment and may include attempts to modify parameters that should not be modifiable. A significant part of the class is devoted to generating test sequences for injecting parameters into creation operations. These sequences are executed on various read-only parameters and try to see if the application can be affected by modifying parameters that should not be modifiable.  Within this fuzzer, you can also find the `generateUpdateInjectionSequence` method, which generates test sequences that test for vulnerabilities in the handling of update parameters by combining create, read and update operations in a sequence. In this case, for each read-only parameter, a sequence is created whereby a resource is created, its parameters are read, and finally an update operation is performed that attempts to inject an unscheduled parameter into the update process."},"rtg-framework/fuzzer/nominal-fuzzer":{"id":"rtg-framework/fuzzer/nominal-fuzzer","title":"Nominal Fuzzer","description":"This fuzzer is designed to generate nominal test sequences for interaction with a REST API. The main purpose of this class is to create test sequences that simulate different input scenarios to test the behavior of an operation.  The `generateTestSequence()` method generates a single test sequence. First, the original operation is cloned into an “editableOperation”. Let us look in detail at the various methods used to value the parameters:"},"rtg-framework/fuzzer/subsequence-error-fuzzer":{"id":"rtg-framework/fuzzer/subsequence-error-fuzzer","title":"Subsequence Error Fuzzer","description":"This class is designed to generate test sequences that simulate errors in sub-sequences of an existing test sequence. Unlike other fuzzers, this class takes an existing test sequence, chooses a sub-sequence and corrupts it, applying mutations to the operation parameters it contains."},"rtg-framework/interaction-processor/graph-inter-processor":{"id":"rtg-framework/interaction-processor/graph-inter-processor","title":"Graph Interaction Processor","description":"This is an implementation of the abstract class InteractionProcessor that updates a dependency graph between API operations based on the responses received in tests.  First of all, it is checked whether the interaction can be processed. In fact, only interactions that have been successfully executed are processed. After that, the interaction is processed. The operation is marked as tested in the dependency graph (OperationDependencyGraph). The response body is analysed to identify parameters that may satisfy dependencies of other operations, and the graph is updated, marking detected dependencies as \"satisfied\"."},"rtg-framework/interaction-processor/interaction-processor":{"id":"rtg-framework/interaction-processor/interaction-processor","title":"Interaction Processor","description":"The abstract class `InteractionProcessor` defines an interface for processing test interactions. Within this class we find two methods: `canProcess`, to check whether an interaction is suitable for processing; `process` used to execute the processing of the interaction.","sidebar":"frameworkSidebar"},"rtg-framework/interaction-processor/jsonparser-inter-processor":{"id":"rtg-framework/interaction-processor/jsonparser-inter-processor","title":"JSON Parser Interaction Processor","description":"This component takes care of interpreting and converting the JSON responses received from the API into an internal parameter structure. This makes the response data more easily usable for subsequent tests."},"rtg-framework/interaction-processor/nlp-inter-processor":{"id":"rtg-framework/interaction-processor/nlp-inter-processor","title":"NLP Interaction Processor","description":"This interaction processor uses natural language processing (NLP) to extract rules from error messages returned by the server. The idea behind this component is to analyse the messages returned in response to incorrect API requests (`400 status code`) to extract useful information and convert this data into testable rules."},"rtg-framework/interaction-processor/request-dictionary-inter-processor":{"id":"rtg-framework/interaction-processor/request-dictionary-inter-processor","title":"Request Dictionary Interaction Processor","description":"This interaction processor stores the parameters of test requests in a global and local dictionary. The objective is to construct and maintain a dictionary of the request parameters used in tests, so that they can be reused in future tests. First, it is checked whether the interaction is processable, i.e. whether it was successfully executed and whether the status code is 200 or 201. If this is satisfied, then the request parameters are processed. After that, the interaction is processed. The parameters are taken from the request and used in the interaction. Leaf parameters and those with an assigned value are filtered out. For each valid parameter, an entry is created and added to the global dictionary. It is also possible to set up a local dictionary."},"rtg-framework/interaction-processor/response-dictionary-inter-processor":{"id":"rtg-framework/interaction-processor/response-dictionary-inter-processor","title":"Response Dictionary Interaction Processor","description":"This interaction processor stores the parameters of API responses in a global dictionary and a local dictionary. The aim is to collect and store the parameter values in the body of the tested API responses in order to be able to reuse them in future tests. Again, it is checked whether the interaction is processable, i.e. whether it was successfully executed and whether the response has a positive status code, i.e. 200 or 201. It is also checked whether the response body isn’t empty. If all conditions are met, then the response body is analysed and the LeafParameters are extracted, null values are excluded, and for each valid parameter an entry is created and added to the global dictionary. If there is also a local dictionary, the entry is also added there."},"rtg-framework/mutator/mutator":{"id":"rtg-framework/mutator/mutator","title":"Mutator","description":"A mutator is a software component that modifies in a controlled manner certain aspects of an entity, such as data, parameters or operations, with the aim of generating variations useful for testing, optimisation or analysis of the robustness of a system.","sidebar":"frameworkSidebar"},"rtg-framework/mutator/operation-mutator/mutate-random-mutator":{"id":"rtg-framework/mutator/operation-mutator/mutate-random-mutator","title":"Mutate Random Parameter With Parameter Mutator Operation Mutator","description":"This is an operation mutator."},"rtg-framework/mutator/parameter-mutator/constraint-violation-mutator":{"id":"rtg-framework/mutator/parameter-mutator/constraint-violation-mutator","title":"Constraint Violation Parameter Mutator","description":"Is a mutator that alters parameter values so as to violate their constraints.  First, it is checked whether a parameter is mutable (i.e. whether it is an enum with predefined values, a string with minimum or maximum length constraints, a number with upper or lower bounds). If the parameter is mutable, then it is modified to violate its constraints. Thus, if the parameter is an enum, a random value is set that does not belong to the list of values; if the parameter is a string, the length constraint is violated; if the parameter is a number, finally, the minimum or maximum value constraint is violated. The aim is to generate invalid input to test the behaviour of the system in the event of errors."},"rtg-framework/mutator/parameter-mutator/missing-required-mutator":{"id":"rtg-framework/mutator/parameter-mutator/missing-required-mutator","title":"Missing Required Parameter Mutator","description":"This mutator is designed to test the operation of the system when mandatory parameters are removed in requests. A parameter is considered mutable if it is mandatory. If the parameter is mutable, then it is removed. Therefore, if the parameter is a `LeafParameter`, the value is deleted; if the parameter is an array, then all values are deleted; if the parameters are of another type, they are directly removed from the operation. The aim is to generate incomplete requests to test the error handling by the REST API under test."},"rtg-framework/mutator/parameter-mutator/wrong-type-mutator":{"id":"rtg-framework/mutator/parameter-mutator/wrong-type-mutator","title":"Wrong Type Parameter Mutator","description":"This mutator is designed to change the type of a parameter incorrectly. First, it is checked whether the parameter is mutable (i.e. type string, number or boolean). The original parameter is replaced with a different type. For example, a string can become a number or a boolean. The choice is made randomly, and the new parameter receives a random value from a ValueProvider. The aim is to simulate erroneous inputs to test whether the system detects and correctly handles type errors in the parameters."},"rtg-framework/operation-sorter/dynamic/graph-based-operation-sorter":{"id":"rtg-framework/operation-sorter/dynamic/graph-based-operation-sorter","title":"Graph Based Operation Sorter","description":"This class extends `DynamicOperationSorter` and orders the operations to be tested according to a dependency structure between operations, represented by a graph (`OperationDependencyGraph`). The aim is to test the operations with fewer unsatisfied parameters and fewer previous test attempts first, optimising the order of the tests. In addition, the maximum attempts that can be made to test a given operation are also managed. In the dependency graph, nodes represent operations, while arcs indicate dependencies between operations. Dependent operations are fulfilled when the required inputs have been produced by previous operations. Note the `removeFirst()` methods that extract the first operation from the queue and the `refresh()` method that repopulates the queue with operations that have not yet been tested. They are ordered by number of unsatisfied parameters, HTTP method (CRUD semantics is followed), number of previous test attempts."},"rtg-framework/operation-sorter/operation-sorter":{"id":"rtg-framework/operation-sorter/operation-sorter","title":"Operation Sorter","description":"There are two type of operation sorter, the static and the dynamic one. Both of them extend the `OperationSorter` class.","sidebar":"frameworkSidebar"},"rtg-framework/operation-sorter/static/random-operation-sorter":{"id":"rtg-framework/operation-sorter/static/random-operation-sorter","title":"Random Operation Sorter","description":"This class implements a random order of the operations to be tested. A list of operations is retrieved from the environment and then a “shuffle” is applied to this list. Unlike the class described above, no structured strategy is followed."},"rtg-framework/oracle/error-status-code-oracle":{"id":"rtg-framework/oracle/error-status-code-oracle","title":"Error Status Code Oracle","description":"This is a test oracle which verifies whether a TestSequence has been handled correctly by the server. It is based on the HTTP status code."},"rtg-framework/oracle/mass-assignment-oracle":{"id":"rtg-framework/oracle/mass-assignment-oracle","title":"Mass Assignment Oracle","description":"This oracle checks whether a test sequence has exposed a Mass Assignment vulnerability. This vulnerability occurs when an attacker is able to modify unintended fields of an object sent to a REST API."},"rtg-framework/oracle/oracle":{"id":"rtg-framework/oracle/oracle","title":"Oracle","description":"This component deals with making assertions on the correct execution of a `TestSequence`. Some implementations of the tool are already provided within the tool. Details of these are explained below.","sidebar":"frameworkSidebar"},"rtg-framework/oracle/producer-consumer-oracle":{"id":"rtg-framework/oracle/producer-consumer-oracle","title":"Producer Consumer Oracle","description":"This oracle assesses whether a test sequence consisting of two interactions operates on the same “object” in a producer-consumer relationship. In other words, it checks whether the output of the first interaction is used as input in the second."},"rtg-framework/oracle/status-code-oracle":{"id":"rtg-framework/oracle/status-code-oracle","title":"Status Code Oracle","description":"This is an oracle that evaluates the outcome of a `TestSequence`, based on the HTTP status codes of the answers.  First, it is checked whether the `TestSequence` was executed and if, at least one `TestInteraction` was not executed, everything is terminated with an error. After that, the status codes of the answers are analysed. If all interactions have a status code of class `2XX`, then the test passes. Otherwise, if at least one interaction has a `5XX` error code, the test is considered to have failed. If neither of these two conditions occur and at least one interaction has an error code of class `4XX` (i.e. client error), then the test is indeterminate."},"rtg-framework/pvp/multi-strategy/enum-example-pvp":{"id":"rtg-framework/pvp/multi-strategy/enum-example-pvp","title":"Enum and Example Priority Parameter Value Provider","description":"This is a multiple selection strategy for choosing a value for the `LeafParameter`. In this case, the two providers `EnumParameterValueProvider` and `ExamplesParameterValueProvider` are retrieved and the available values for each provider are counted. If at least one of the two has available values, a decision is made whether to choose one of them with a probability of 80%. In this case, a random choice is made between the EnumParameterValueProvider and the ExamplesParameterValueProvider."},"rtg-framework/pvp/multi-strategy/global-dictionary-pvp":{"id":"rtg-framework/pvp/multi-strategy/global-dictionary-pvp","title":"Global Dictionary Priority Parameter Value Provider","description":"This multiple value selection strategy gives priority to the answer dictionary.  First, an attempt is made to obtain a value from the answer dictionary and, if there are values available, one of these is returned. If, on the other hand, the dictionary does not return any values, other strategies are then tried using the `EnumParameterValueProvider`, `ExamplesParameterValueProvider` and `DefaultParameterValueProvider`. At this point, if none of the previous strategies provided a value, the random generation with Random or Narrow Random strategy is performed."},"rtg-framework/pvp/multi-strategy/keep-last-id-pvp":{"id":"rtg-framework/pvp/multi-strategy/keep-last-id-pvp","title":"Keep Last ID Parameter Value Provider","description":"The main objective of this strategy is to maintain and reuse the last observed ID value for a parameter. In this way, an intelligent approach is attempted, avoiding generating new IDs when an existing one can be reused. If the value is not available, on the other hand, various strategies are tried until random generation."},"rtg-framework/pvp/multi-strategy/local-dictionary":{"id":"rtg-framework/pvp/multi-strategy/local-dictionary","title":"Local Dictionary Priority Parameter Value Provider","description":"This technique attempts to value a `LeafParameter`, using different strategies, but still giving priority to the use of the local dictionary. Nevertheless, if the local dictionary does not have a valid value, it switches to other strategies."},"rtg-framework/pvp/multi-strategy/multi-strategy":{"id":"rtg-framework/pvp/multi-strategy/multi-strategy","title":"Multi Strategy","description":"Multi strategies include the classes: `EnumAndExamplePriorityParameterValueProvider`, `RandomProviderParameterValueProvider`, `KeepLastIdParameterValueProvider`, `LocalDictionaryPriorityParameterValueProvider`."},"rtg-framework/pvp/multi-strategy/random-pvp":{"id":"rtg-framework/pvp/multi-strategy/random-pvp","title":"Random Provider Parameter Value Provider","description":"This class implements a flexible strategy for selecting parameter values by randomly choosing from several available sources. Two lists are defined, one of always available providers (`RandomParameterValueProvider` and `NarrowRandomParameterValueProvider`) and one of candidate providers (Default, Enum, Examples, ResponseDictionary, RequestDictionary, LastResponseDictionary, LastRequestDictionary). The providers are filtered to exclude those with no available values and a source is randomly chosen from the remaining ones."},"rtg-framework/pvp/pvp":{"id":"rtg-framework/pvp/pvp","title":"Parameter Value Provider","description":"This set of classes is used to provide a value to various parameters, based on different valuation methodologies. In the implementation of RestTestGen, we find two macro-types: single and multiple (i.e. combining several single strategies).","sidebar":"frameworkSidebar"},"rtg-framework/pvp/single-strategy/default-pvp":{"id":"rtg-framework/pvp/single-strategy/default-pvp","title":"Default Parameter Value Provider","description":"When a parameter is requested, the class attempts to retrieve the default values given in the OpenAPI specification. If the `SAMENAME` mode is enabled, it collects the default values of all parameters with the same name; if the `SAMENORMALISED_NAME` mode is enabled, it collects those with the same normalized name; in all other cases, it uses only the default value of the specific parameter."},"rtg-framework/pvp/single-strategy/enum-pvp":{"id":"rtg-framework/pvp/single-strategy/enum-pvp","title":"Enum Parameter Value Provider","description":"When a parameter is requested, this class uses the enumerated values (enum) defined in the OpenAPI specification. By default, only the values of the specific parameter are taken, however, it is also possible to set `SAMENAME` or `SAMENORMALISED_NAME`."},"rtg-framework/pvp/single-strategy/examples-pvp":{"id":"rtg-framework/pvp/single-strategy/examples-pvp","title":"Examples Parameter Value Provider","description":"When a parameter value is requested, the default example values in the OpenAPI specification are used. In this way, the example values are documented and realistic."},"rtg-framework/pvp/single-strategy/last-request-pvp":{"id":"rtg-framework/pvp/single-strategy/last-request-pvp","title":"Last Request Dictionary Parameter Value Provider","description":"A global dictionary is relied upon to value parameters with this technique. This contains the values collected from previous API requests, allowing the most recent data to be reused. By default, the provider uses the global dictionary of requests that is available in the Environment. This dictionary contains DictionaryEntries that associate parameters with specific values recorded during previous API requests. The constructor sets the mode `SAMENORMALISEDNAME`, which means that values will be collected not only from parameters with the same name, but also from those with the normalised name."},"rtg-framework/pvp/single-strategy/last-response-pvp":{"id":"rtg-framework/pvp/single-strategy/last-response-pvp","title":"Last Response Dictionary Parameter Value Provider","description":"Similar to the class described above, values from a dictionary are also used here. However, the values are taken from a global response dictionary, i.e. from data obtained from the answers of executed requests. By default, the class uses the global response dictionary which is available via `Environment.getInstance()`. The constructor sets the `SAMENORMALISEDNAME` mode, allowing values to be collected not only by the exact name of the parameter, but also by its normalised name."},"rtg-framework/pvp/single-strategy/request-pvp":{"id":"rtg-framework/pvp/single-strategy/request-pvp","title":"Request Dictionary Parameter Value Provider","description":"Through this value provider, parameters can be given a value using a global request dictionary. A dictionary is used that collects the values used in previous requests, allowing them to be reused in subsequent requests."},"rtg-framework/pvp/single-strategy/response-pvp":{"id":"rtg-framework/pvp/single-strategy/response-pvp","title":"Response Dictionary Parameter Value Provider","description":"Through this value provider, parameters can be given a value using a global dictionary of answers. A dictionary is used that collects values from previous answers. By default, the class uses the global response dictionary, obtained via `Environment.getInstance().getGlobalResponseDictionary()`. The constructor sets the `SAMENORMALISEDNAME` mode, allowing values to be collected not only from the exact name of the parameter, but also from its normalised name. By default, the option to remove duplicates is enabled to avoid returning redundant values."},"rtg-framework/pvp/single-strategy/single-strategy":{"id":"rtg-framework/pvp/single-strategy/single-strategy","title":"Single Strategy","description":"Individual strategies include the classes: `DefaultParameterValueProvider`, `EnumParameterValueProvider`, `ExamplesParameterValueProvider`, `LastRequestDictionaryParameterValueProvider`, `LastResponseDictionaryValueProvider`, `RequestDictionaryParameterValueProvider`, `ResponseDictionaryParameterValueProvider`. They all extend the `CountableParameterValueProvider` class, which in turn extends the abstract `ParameterValueProvider` class. An example of a hierarchy can be found in the figure below."},"rtg-framework/writer/coverage-report":{"id":"rtg-framework/writer/coverage-report","title":"Coverage Report Writer","description":"The purpose of this class is to collect test case coverage data, organise it in JSON format and save it in a dedicated folder so that it can be easily analysed. The information is retrieved on the basis of the Coverage Manager component, which contains the information collected during the test session."},"rtg-framework/writer/report-writer":{"id":"rtg-framework/writer/report-writer","title":"Report Writer","description":"This class is useful for generating and storing detailed reports on `TestSequences`, allowing the results to be analysed later. The JSON structure facilitates integration with other data analysis or visualisation tools."},"rtg-framework/writer/rest-assured-writer":{"id":"rtg-framework/writer/rest-assured-writer","title":"RestAssured Writer","description":"Allows the created `TestSequence` to be converted into test cases using the RestAssured framework. The class consists of various methods for creating a suitable test class. First, the necessary imports are defined and the actual class is generated with its annotations. Then, for each `TestInteraction` in the sequence, the corresponding method within the test class is generated. This means that for each `TestInteraction`, the method signature is created, the parameters are initialised, the request to be performed is defined and, finally, the assertions are also specified."},"rtg-framework/writer/writer":{"id":"rtg-framework/writer/writer","title":"Writer","description":"The framework provides a component that allows the various `TestSequences` to be written to file. This is useful when a researcher or programmer needs to have a clearer view of the various tests that have been performed on the REST API under test.  At the moment, only three implementations are provided, however, it is possible to create others as desired and according to individual needs.","sidebar":"frameworkSidebar"},"rtg-tool/prova":{"id":"rtg-tool/prova","title":"AAAAAAA","description":""},"rtg-tool/strategy/introduction":{"id":"rtg-tool/strategy/introduction","title":"Strategy","description":"To execute RestTestGen, the `main()` method inside the App class within the package `io.resttestgen.boot.cli` is executed. Within the project, there is also a configuration file `rtg-config.yml` in which anyone wishing to use the tool must specify the strategy to be used and the API to be tested.","sidebar":"strategiesSidebar"},"rtg-tool/strategy/mass-assignment-strategy":{"id":"rtg-tool/strategy/mass-assignment-strategy","title":"Mass Assignment Strategy","description":"The \"mass assignment\" vulnerability is one of the peculiar vulnerabilities of this application domain. This vulnerability originates from a misconfiguration of any REST API framework that can provide an automatic binding between input data fields (controlled by a potential attacker) and the internal data representation (e.g. database columns). Successful exploitation of such a vulnerability may allow malicious attackers to manipulate private data. However, they would have to guess the names of the internal data structures (e.g. database tables and columns) used by the REST API.","sidebar":"strategiesSidebar"},"rtg-tool/strategy/nlp-strategy":{"id":"rtg-tool/strategy/nlp-strategy","title":"NLP Strategy","description":"The idea of this strategy is to apply natural language processing techniques to improve the testing of REST APIs. Given an OpenAPI specification, some additional rules are extracted based on the human-readable part of the specification. Consider, for example, a particular specification that describes the parameters of a particular request. We may, for example, have the parameter `language` to which is associated a `description` in which the accepted values are made explicit. Similarly, we may have a `count` parameter to which, again, is associated a `description` field in which it is specified that the maximum value is `50`. In these two cases, a normal automated testing tool could miss these characteristics and thus create unsuitable or failing test cases.","sidebar":"strategiesSidebar"},"rtg-tool/strategy/nominal-error-strategy":{"id":"rtg-tool/strategy/nominal-error-strategy","title":"Nominal and Error Strategy","description":"The objective of this strategy is to successfully test all the operations in the REST API that are to be investigated. To do this, an ordering based on the Operation Dependency Graph (ODG) is defined. For all other responsibilities (generation of input values, oracles and writers), this strategy is based on basic components available in the framework.","sidebar":"strategiesSidebar"},"rtg-tool/strategy/strategy":{"id":"rtg-tool/strategy/strategy","title":"Strategy","description":"To execute RestTestGen, the `main()` method inside the App class within the package `io.resttestgen.boot.cli` is executed. Within the project, there is also a configuration file `rtg-config.yml` in which anyone wishing to use the tool must specify the strategy to be used and the API to be tested."}}}}