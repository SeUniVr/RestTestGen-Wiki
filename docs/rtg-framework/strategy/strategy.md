# Strategy
To execute RestTestGen, the ```main()``` method inside the App class within the package ```io.resttestgen.boot.cli``` is executed. Within the project, there is also a configuration file ```rtg-config.yml``` in which anyone wishing to use the tool must specify the strategy to be used and the API to be tested.

In this case, the file looks like this:
```yaml
apiUnderTest: myApi
strategyClassName: myStrategy
```

When implementing a new strategy, the ```Strategy class```, which is already present, must necessarily be extended and the ```start()``` method overridden to define custom behaviour.

The strategy is nothing more than the entry point of the tool, and within the above-mentioned method, the logic to be followed during the test session is defined. Thus, the ordering of operations is defined, the way in which parameters are valorised, how to calculate the performance of the tests performed and, finally, it is also possible to define how to write test cases using a ```Writer```.   

A few strategies have already been implemented within the tool. They will be described in detail below.  

- **NominalAndErrorStrategy**: the objective of this strategy is to successfully test all the operations in the REST API that are to be investigated. To do this, an ordering based on the Operation Dependency Graph (ODG) is defined. For all other responsibilities (generation of input values, oracles and writers), this strategy is based on basic components available in the framework. 
    - ***Operation Ordering***: p to generate the nominal test cases, the concrete implementation of the ordering of operations is a dynamic strategy based on the operation dependency graph. The next operation to be tested is taken by consulting the ODG, taking an operation that has yet to be tested and minimising the number of unsatisfied producer-consumer relations. In addition to this, the order of operations is arranged according to CRUD semantics (e.g. delete operations are the last to be tested).   
    - ***Input Value Provider***: the Enum and Example Priority Input Value Provider is used. In this way, an attempt is made to take advantage of all possible single strategies available.
    - ***Oracles***: the results of the test cases are evaluated according to the two available oracles. Status codes are evaluated according to the Oracle Status Code, while the format of answers is evaluated according to the Oracle Validation Schema.
    - ***Writers***: The test cases are written in RestAssured. A report in JSON containing the results of the various ```TestSequences``` is also produced.     
    
    Once nominal testing is performed, **error testing** is also performed, which aims to test the API with scenarios that violate the specification to try to reveal faults in the handling of incorrect requests. This testing strategy starts with Nominal Tester requests that have been successfully executed (i.e ```2XX status code```). These are modified through customised mutation operations defined by this strategy. In addition, error testing provides a customised sorting and oracle. The other components are those available in the framework.
    - ***Operation Ordering***: for each Test Sequence of nominal test length n, all sub-sequences are calculated from the first interaction of the original sequence, with incremental length from 1 to n. Mutation operators are applied to the last interaction of each of these sequences.
    - ***Mutation Operators***: three concrete implementations of mutation operators are provided:
        - **Missing Required**: removes a mandatory input parameter from an operation to produce malformed input. It only applies to parameters marked as mandatory in the specification. 
        - **Wrong Input Type**: changes the type of an input parameter, e.g. an integer parameter is assigned a string value. The random input value provider generates a random value of the new type.
        - **Constraint Violation**: modifies the value of a parameter to make it contrary to the constraints of the specification. For example, it may add more characters to a string to make it longer than its maximum length.
        - **Oracles**: the Oracle Validation Schema is integrated to check the validity of the response format. There is also a customised oracle called the Error Status Code. It is implemented to verify the outcome of error scenario testing, based on the assumption that an erroneous request should be rejected by a well implemented API. If a request is rejected (```4XX status code```), the test is classified as ```PASS```. If a request is accepted (```2XX status code```), the test is classified as ```FAIL```. If a server error is observed (```5XX status code```), the test is considered ```FAIL```.   
        - **Writers**: both the JSON report writer and the writer for writing test cases in RESTAssured are integrated. 

- **MassAssignmentSecurityTesting**: the "mass assignment" vulnerability is one of the peculiar vulnerabilities of this application domain. This vulnerability originates from a misconfiguration of any REST API framework that can provide an automatic binding between input data fields (controlled by a potential attacker) and the internal data representation (e.g. database columns). Successful exploitation of such a vulnerability may allow malicious attackers to manipulate private data. However, they would have to guess the names of the internal data structures (e.g. database tables and columns) used by the REST API. 

    RTG provides a strategy for trying to detect this flaw within the REST API to be tested. In this case, the latter's specification is analysed to see which data should not be overwritten by incoming requests. These are the read-only data that are supposed to be good candidates for the mass assignment attack. Next, concrete test scenarios are generated by instantiating them from a catalogue of abstract test patterns. Finally, a security oracle monitors the execution of these test cases to reveal when a vulnerability is exposed. 

    The OWASP Foundation provides some guidelines for detecting and mitigating mass assignment vulnerabilities even if the source code is not available, as in the case of black box testing. The guidelines must be implemented manually by developers as there is no suggestion on how to make this procedure automatic.In RTG, therefore, a security testing approach is proposed to automatically find potential vulnerabilities of this type in REST APIs.   
    The proposed strategy for testing the vulnerability of mass assignment consists of three main steps: 
    - ***Identification of read-only attributes***: the OpenAPI specification is analysed, and operations and their input and output parameters are identified. Operations are subject to clustering, i.e. they are grouped according to the resources they handle. Then, operations that handle similar resources are compared to identify those that handle read-only attributes (i.e. those that appear in read operations, but not in write operations).  The semantics of the operations are inferred based on the HTTP method that is used. In particular, operations using the ```POST``` method are annotated with ```C``` (Create); operations using the ```GET``` method to read a single resource are annotated with ```R``` (Read), while they are annotated with ```RM``` (Read Multi) if they read multiple resources at a time; operations using ```PUT``` and ```PATCH```, on the other hand, are annotated with ```U``` (Update); finally, operations using the ```DELETE``` method are annotated with ```D``` (Delete).
    As mentioned above, operations with the most similar parameters are clustered. To do this, the EM (Expectation Maximisation) algorithm is used. First, input and output parameter names are collected for all operations in the specification. The names are normalized according to Porter's stemming algorithm, duplicate names are discarded, and the remaining ones are sorted alphabetically. When the clustering algorithm is applied, the optimal number of clusters is automatically defined, and which operations belong to each cluster based on the parameters in common.   
    - ***Test case generation***: test scenarios are automatically generated as sequences of requests with the purpose of overwriting read-only attributes.   
    - ***Security Oracle***: test cases are executed on the REST API and their execution is monitored by this oracle (security oracle). The oracle reveals that a mass assignment vulnerability has been correctly exposed when a test case manages to overwrite a read-only attribute. To this purpose, the oracle verifies that the same resource-id is used by all operations in a sequence and that the injection was successful with a value other than the default.   

- **NlpStrategy**: the idea of this strategy is to apply **natural language processing techniques** to improve the testing of REST APIs. Given an OpenAPI specification, some additional rules are extracted based on the human-readable part of the specification. Consider, for example, a particular specification that describes the parameters of a particular request. We may, for example, have the parameter ```language``` to which is associated a ```description``` in which the accepted values are made explicit. Similarly, we may have a ```count``` parameter to which, again, is associated a ```description``` field in which it is specified that the maximum value is ```50```. In these two cases, a normal automated testing tool could miss these characteristics and thus create unsuitable or failing test cases.   
In addition to this, it is also possible that natural language descriptions within the specification can identify **inter-parameter dependencies** that would otherwise not be detected.    

    It should be noted that the set of rules extracted through NLP techniques may also contain some incorrect ones due to natural language ambiguity. To mitigate this problem, this strategy includes a validation phase that verifies the NLP-extracted rules with the API implementation, creating and executing validation test cases, and discards rules that fail this validation. During this rule validation phase, validity checks are performed. In some cases, validation may also lead to corrections to the extracted rules. Rule validation consists of two phases: the **static pruning phase** (in which rule combinations are discarded by statically analysing the compatibility between the rules) and the **dynamic pruning phase** (in which rule combinations are dynamically validated by sending requests to a distributed instance of the API and checking the resulting HTTP responses).   
    
    Once this is done, a **fine-tuning phase** is performed to further assess the validity of the rules. In this phase, a strategy is applied that reproduces the successful requests identified in the previous phase by applying a series of mutations to further validate each potentially valid rule.  For example, to validate rules of the required type, the request is reproduced twice, with and without the required parameter. If the request without the parameter is also successful, it is discarded. To validate if-then rules, the request is played twice, once applying the predicate and once applying its negation. If the first request succeeds and the second is rejected, the rule is validated as valid. In addition to validating rules, fine tuning can also attempt to repair the inter-parameter dependency rules **Or**, **OnlyOne**, **AllOrNone** and **ZeroOrOne**.   